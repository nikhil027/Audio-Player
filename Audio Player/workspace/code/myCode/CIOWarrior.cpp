/*
 * CIOWarrior.cpp
 */
/**
 * \file CIOWarrior.cpp
 *
 * \brief implementation of the IOWarrior control class (performs output only)
 */
#include <iostream>
using namespace std;

#include "CIOWarrior.h"
#include "CASDDException.h"

CIOWarrior::CIOWarrior()
{
	m_handle=NULL;
	m_lastError=IOW_E_OK;
	m_state=IOW_S_NOTREADY;
}

CIOWarrior::~CIOWarrior()
{
	close();
}

bool CIOWarrior::open()
{
	// evaluate state
	if(m_state == IOW_S_READY)
		return true;

	// call the API open function
	m_handle=IowKitOpenDevice();
	if(m_handle == NULL)
	{
		m_lastError=IOW_E_NODEVICE;	// set error value
		return false;
	}
	// call the API get product ID function
	if(IowKitGetProductId(m_handle) != IOWKIT_PRODUCT_ID_IOW40)
	{
		// set error value
		m_lastError=IOW_E_INVALIDDEVICE;	// set error value
		// close the device
		IowKitCloseDevice(m_handle);
		return false;
	}
	// try to set all IOWarrior port pins to 1
	IOWKIT40_IO_REPORT myreport;
	myreport.Value=0xffffffff;
	if( IowKitWrite(m_handle, IOW_PIPE_IO_PINS, (PCHAR)&myreport, IOWKIT40_IO_REPORT_SIZE)!=IOWKIT40_IO_REPORT_SIZE)
	{
		IowKitCloseDevice(m_handle);
		m_lastError=IOW_E_WRITEERROR;
		return false;
	}
	// set device state to ready
	m_state=IOW_S_READY;
	// set error to ok
	m_lastError=IOW_E_OK;
	return true;
}

void CIOWarrior::close()
{
	if(m_state == IOW_S_NOTREADY)
		return;
	IowKitCloseDevice(m_handle);
	m_state = IOW_S_NOTREADY;
	m_handle=NULL;
}


bool CIOWarrior::write(unsigned char data)
{
	// check the state
	if(m_state != IOW_S_READY)
	{
		m_lastError=IOW_E_DEVICENOTREADY;
		return false;
	}
	// define a report structure variable
	IOWKIT40_IO_REPORT myreport;
	myreport.ReportID=0; 				// plain io ID
	myreport.Value=0xffffffff;
	myreport.Bytes[3]=~data;			// 0-bit switches LED on, 1-bit off
	int res=IowKitWrite(m_handle, IOW_PIPE_IO_PINS, (char*)&myreport, sizeof(myreport));
	if(res != sizeof(myreport))
	{
		m_lastError=IOW_E_WRITEERROR;
		close();
		return false;
	}
	return true;
}

// KeyPressed: looks for a pressed button and returns immediately
// it is not necessary to wait for the user to release the button, because as long as the state of the ports
// doesn't change no new report will be generated by the device
bool CIOWarrior::keyPressed()
{
	if(m_state!=IOW_S_READY)
		return false;
	// use local report structure variable to avoid the change of port pin 0.0 during write (or see write method)
	IOWKIT40_IO_REPORT data;
	if (sizeof(IOWKIT40_IO_REPORT) == IowKitReadNonBlocking(m_handle, IOW_PIPE_IO_PINS, (char *) &data, sizeof(IOWKIT40_IO_REPORT)))
	{
		//cout << "Port: " << hex << data.Value << endl;
		if (data.Bytes[0] != 0xff)
		{
			// set port 0 if you use m_report for reading as well, otherwise the first button input causes P0.0 to become an
			// output pin and makes the button useless
		//	m_report.Bytes[0]=0xff;
			return true;
		}
	}
	return false;
}


void CIOWarrior::printData(unsigned char cByte)
{
	for(int i=0;i<8;i++)
	{
		cByte & 0x80 ? cout << '1' : cout << '0';
		cByte <<= 1;
	}
	cout << '\r';
}

void CIOWarrior::printState()
{
	switch(m_state)
	{
	case IOW_S_NOTREADY: cout << "device is not ready" << endl; break;
	case IOW_S_READY: cout << "device is ready" << endl; break;
	default: cout << "Unknown State" << endl; break;
	}
	switch(m_lastError)
	{
	case IOW_E_NODEVICE: cout << "Error: no device" << endl; break;
	case IOW_E_INVALIDDEVICE: cout << "Error: Invalid device" << endl; break;
	case IOW_E_WRITEERROR: cout << "Error: could not write" << endl; break;
	case IOW_E_DEVICENOTREADY: cout << "Error: please open the device first" << endl; break;
	case IOW_E_OK: cout << "No Error :-)" << endl; break;
	default: cout << "Unknown Error" << endl; break;
	}
}

IOW_STATES CIOWarrior::getState()
{
	return m_state;
}

//********************************************
// IOWarrior Control with exception handling
//
CIOWarriorEx::CIOWarriorEx()
{
	m_handle=NULL;
	m_state=IOW_S_NOTREADY;
}

CIOWarriorEx::~CIOWarriorEx()
{
	close();
}

void CIOWarriorEx::open()
{
	// evaluate state
	if(m_state == IOW_S_READY)
		return;

	// call the API open function
	m_handle=IowKitOpenDevice();
	if(m_handle == NULL)throw CASDDException(SRC_IOWarrior, IOW_E_NODEVICE, getIOWErrorText(IOW_E_NODEVICE));

	// call the API get product ID function
	if(IowKitGetProductId(m_handle) != IOWKIT_PRODUCT_ID_IOW40)
	{
		// close the device
		IowKitCloseDevice(m_handle);
		throw CASDDException(SRC_IOWarrior, IOW_E_INVALIDDEVICE, getIOWErrorText(IOW_E_INVALIDDEVICE));
	}
	// try to set all IOWarrior port pins to 1
	IOWKIT40_IO_REPORT myreport;
	myreport.Value=0xffffffff;
	if( IowKitWrite(m_handle, IOW_PIPE_IO_PINS, (PCHAR)&myreport, IOWKIT40_IO_REPORT_SIZE)!=IOWKIT40_IO_REPORT_SIZE)
	{
		IowKitCloseDevice(m_handle);
		throw CASDDException(SRC_IOWarrior, IOW_E_WRITEERROR, getIOWErrorText(IOW_E_WRITEERROR));
	}
	// set device state to ready
	m_state=IOW_S_READY;
}

void CIOWarriorEx::close()
{
	if(m_state == IOW_S_NOTREADY)
		return;
	IowKitCloseDevice(m_handle);
	m_state = IOW_S_NOTREADY;
}


void CIOWarriorEx::write(unsigned char data)
{
	// check the state
	if(m_state != IOW_S_READY)throw CASDDException(SRC_IOWarrior, IOW_E_DEVICENOTREADY, getIOWErrorText(IOW_E_DEVICENOTREADY));

	// define a report structure variable
	IOWKIT40_IO_REPORT myreport;
	myreport.ReportID=0; 				// plain io ID
	myreport.Value=0xffffffff;
	myreport.Bytes[3]=~data;			// 0-bit switches LED on, 1-bit off
	int res=IowKitWrite(m_handle, IOW_PIPE_IO_PINS, (char*)&myreport, sizeof(myreport));
	if(res != sizeof(myreport))
	{
		close();
		throw CASDDException(SRC_IOWarrior, IOW_E_WRITEERROR, getIOWErrorText(IOW_E_WRITEERROR));
	}
}

// KeyPressed: looks for a pressed button and returns immediately
// it is not necessary to wait for the user to release the button, because as long as the state of the ports
// doesn't change no new report will be generated by the device
bool CIOWarriorEx::keyPressed()
{
	if(m_state!=IOW_S_READY)
		return false;

	// use local report structure variable to avoid the change of port pin 0.0 during write (or see write method)
	IOWKIT40_IO_REPORT data;
	if (sizeof(IOWKIT40_IO_REPORT) == IowKitReadNonBlocking(m_handle, IOW_PIPE_IO_PINS, (char *) &data, sizeof(IOWKIT40_IO_REPORT)))
	{
		cout << "Port: " << hex << data.Value << endl;
		if (data.Bytes[0] != 0xff)
		{
			// set port 0 if you use m_report for reading as well, otherwise the first button input causes P0.0 to become an
			// output pin and makes the button useless
		//	m_report.Bytes[0]=0xff;
			return true;
		}
	}
	return false;
}


void CIOWarriorEx::printData(unsigned char cByte)
{
	for(int i=0;i<8;i++)
	{
		cByte & 0x80 ? cout << '1' : cout << '0';
		cByte <<= 1;
	}
	cout << '\r';
}

void CIOWarriorEx::printState()
{
	switch(m_state)
	{
	case IOW_S_NOTREADY: cout << "device is not ready" << endl; break;
	case IOW_S_READY: cout << "device is ready" << endl; break;
	default: cout << "Unknown State" << endl; break;
	}
}

IOW_STATES CIOWarriorEx::getState()
{
	return m_state;
}

const char* CIOWarriorEx::getIOWErrorText(IOW_ERRORS err)
{
	switch(err)
	{
	case IOW_E_OK:
		return "all is ok :-)";
	case IOW_E_NODEVICE:
		return "No device found.";
	case IOW_E_INVALIDDEVICE:
		return "Wrong device (IOWarrior40 needed).";
	case IOW_E_DEVICENOTREADY:
		return "Device not ready (call open first).";
	case IOW_E_WRITEERROR:
		return "Failed to write.";
	default:
		return "unknown error";
	}
}
